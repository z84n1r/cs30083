java c 
CEG2136: Computer Architecture I 
LAB 4                      BASIC COMPUTER ORGANIZATION
1. Objectives In this laboratory, students will analyse the structure of a basic computer, will devise, design, implement, simulate in Quartus and, if will be physically present in the lab, will test experimentally its control unit on Altera platform; furthermore, students will use opcodes to write simple programs in machine  code.  The  design  must  function  in  simulation,  and  also  on  the  DE2-115  Altera development board, if physically present in the lab.
2. Equipment and Supplies: 
* Quartus II (student edition or web edition)
* Altera DE2-115 board with
- USB-blaster cable
- Power supply 12 VDC, 2A
3. References 
.    You are provided with all the .bdf files, except one that describes the combinational circuits which generates the output and transition functions of the Control Unit and which you are expected to conceive and develop. Their logic diagrams are annexed to this document.
.     Chapters 5 and 6 of the textbook: Computer Systems Structures, Morris Mano, 3rd edition, 1993, ISBN 0-13-175563-3.
.    The course notes
.    The user guide of the Altera DE2-115 development kit is provided in the Laboratories > Documentation section of your CEG2136 Virtual Campus.
4. The Structure of the Basic Computer 
4.1 General View 
This laboratory implements a computer having a structure that is very close to the one presented in figure 5.4 on page 130 of your textbook. However, there are two major differences:
1.   The designed computer’s memory (storing both programs and data) has a capacity of 256 words of
8 bits (256 x 8). In the textbook, the BASIC computer has a memory with words of 16 bits, each word being capable of storing one memory-reference instruction (which consists there of a 4-bit opcode and a 12-bit memory address). In this lab, a memory-reference instruction is 2 byte long as well, but the msb byte carries the opcode, while the lsb byte contains the operand address (8 bits are enough to address a memory space of 28 = 256 memory locations); as such, a 2-byte memory- reference instruction is stored in 2 consecutive memory locations (two 1-byte words).
Consequently, two successive READ cycles are needed to fetch a memory-reference instruction: first to get the opcode, and the second to get the address of the data that the opcode will use.
2.   The second major difference consists in the additional circuits which will allow a user to visualize the contents of the memory independently of having a program running or not on the DE2-115 board.User can preset the DIP switches on the board with the memory address to be visualized. Before the fetch phase of each instruction, the BASIC computer reads the contents of the memory location pointed at by the DIP switches on the board and shows it in hexadecimal format on the 7 segment display of the board.The block diagram of your computer is presented in Figure 1. The .bdf files of all the component blocks, except the Instruction Decoder (lab_controller of CU), will be provided. The Control Unit functions in accord with a time sequence which is generated by the sequence counter (SC) that plays the role of FSM state register. The SC initial state is 0; it restarts counting from 0 at the beginning of each instruction of a program and it is reset to 0 once that instruction is finished. A decoder converts the 4- bit output of the SC into time-signals, distinct for each possible output (for example, when the SC output is 0010, then the T2  output of the decoder will go high, if not, it will remain low for any other combination); this combination of the SC and its decoder implement a One-hot encoded state register. The control commands for the Datapath are synthesized by the Instruction Decoder as (FSM output) functions in terms of the contents of the IR, DR and other signals from the Datapath; a set of gates (AND, OR, and NOT) forms the Instruction Decoder. As some CU outputs are of Mealy type, a bank of buffer registers (Control Register) is used to insure a duration of one clock period for the control commands that are generated by the CU, and to synchronize them with the system clock.
Figure 1:  Computer block diagram 
The following sequence of steps (grouped in 3 sets – Display, Fetch and Execution) is repeated for each instruction cycle, as long as Stop Register = 0:
Display 
1.   The address of the memory location to being displayed (specified by the DIP switches) is loaded from register OUTA to register AR.
2.   The content of memory location at this address is loaded into OUTD whose output is connected to the 7-segment display. Steps 1 and 2 are always executed, even if the system is in halt.
Fetch 
3.   The content of the Program Counter PC (containing at this point the address of the current instruction) is loaded into AR (address register). PC determines the address of the memory location from where the instruction is fetched (read) into the IR of the CPU. Since PC is reset to
0 whenever the UP2 board is programmed, your program’s first instruction has to be stored in the first memory location (address 00).
4.   PC is incremented to be prepared for getting the next instruction byte.
5.   The first byte of the instruction (opcode) is fetched from memory and is stored in IR (instruction register).
6.   The IR content (instruction opcode) is decoded by the Instruction Decoder (in Control Unit).
7.   If the instruction refers to a register, then skip to step 10.
8.   If the instruction refers to memory, the PC content is transferred to AR, to get the second byte of the instruction. This second byte of the instruction may contain
. either the address of the operand - if direct addressing mode; the instruction’s second byte (the operand address) is read and directly loaded into AR;
. or the pointer to the operand address (i.e., address of the operand address) if indirect addressing; This pointer is read from the memory location pointed by instruction’s 2nd  byte and is loaded to AR; then a newer read is performed to get the operand address and move it to AR.
The FETCH cycles conclude with AR carrying the operand address.
Execution 
9.   The data (operand) is read from the memory, and the PC is incremented to pointing to the next instruction and being prepared for the next FETCH.
10. The EXECUTION cycles of the instruction are implemented, which requires typically several more steps.
11. In the last cycle of the execution the SC is reset to 0, and the procedure begins again at step 1. NOTE:
.    Setting Stop Register = 1=> blocks incrementing PC and stops running further instructions. These steps will be discussed in detail below.
.   You will use a new type of file for memory initialization (.mif), to specify the contents of memory; just go to “File” and open a “New” file which will display the list of file formats from where you should select “Memory Initialisation File.” For this lab,the file .mif has to be named memorycontents8.mif. To use hex numbers, you have to right-click on the Addr region and then choose Hexadecimal for both Address and Memory (content) Radix. Save Every time you change the contents of this file, you have to save and recompile your project.
.   Everytime you want to run the program that you loaded in the memory, you have to reprogram your device.
4.3 Syntax of the computer instructions 
The instructions that can be executed by the computer are shown in Table 1.
.   The  second  most  significant  bit  (IR6)  specifies  if  the  instruction  is  a memory-reference instruction (IR6  = 0) or a register-reference instruction (IR6  = 1).
.   The msb (I = IR7) specifies the instruction addressing mode (direct or indirect), while
.   the  other  6 bits  form. the opcode.  For memory-reference  instructions (IR6=0)  with direct addressing mode (IR7=0) another memory access is needed to read the operand, while two more memory read cycles are needed to get the operand in case of indirect addressing. In conclusion,
register-reference instructions are encoded with one byte: {opcode} with IR6  = 1,
memory-reference instructions employ a two-byte format as follows:
o memory-reference instructions with direct addressing: {opcode with IR7,6=00, operand address}
o memory-reference instructions in indirect addressing: {opcode, address of the operand address}. Table 1: Computer Instructions List 
Now let us consider the following example file which presents a simple program in the memory
(in machine code and commented with assembly language): The hex number of the first column indicates the address in the memory, while the second hex number indicates the instruction (opcode or operand’s address) represented in machine code. The symbol % delimits the comments; these comments will contain the assembly language mnemonics of opcode of the instructions at hand (assembly language representation).From operating point of view, the memory space of our computer is divided in two: the first half (00-7F) carries the code of your program, while the second half (80-FF) is dedicated to storing data (initial operands and results).
(#00)  The program starts at address 00, with memory –reference instruction LDA that loads the register AC with a number which is stored at address 80H; this number is 1AH.
(#02)  The second program line contains a register-reference instruction, ASL, which is executed in only one reading cycle of memory. The AC contents are shifted to the left and become 34H.
(#03)  This instruction adds the number stored at address 81H to the AC, i.e., performs 34H+2BH= 5FH (#05) Next instruction stores the sum obtained in AC at address A0H.(#07)  An indirect subtraction is performed here. Address 90H contains a pointer to the address 82H, where the number to being subtracted (65H) is stored. The operation is then 5FH– 65H = 0FH;(#9)    The resulted difference 0FH (of AC) is stored at memory address A1H, and the program stops.  Choosing addresses A0H and A1H by DIP, the numbers 5FH and FAH, respectively, can be seen on the 7-segment displays.
The .mif file which represents this program in machine code (bold characters of the above example) is shown in fig. 2 as it is stored in the memory.
Figure 2: .mif file which represents the program in machine code 
4.4       Detailed Description of the Control Functions (to be generated by the Control Unit)
Starting from Table 1, one can observe that there are three types of distinct instructions that are encoded by the two most significant bits of the instruction register (IR):
1. X0   = IR7 IR6    indicates a direct memory-reference instruction;
2. X1  = IR7IR6    indicates a register-reference instruction 
3. X2   = IR7 IR6     indicates an indirect memory-refer代 写CEG 2136 LAB 4 BASIC COMPUTER ORGANIZATIONProcessing
代做程序编程语言ence instruction.The seven memory-reference instructions can be discriminated by the following control signals (note that X0  + X2  = IR6 ), employing the one-hot encoding (LDA; STA; BUN; and ISZ) and partially binary encoding (AND, ADD and SUB).
1. Y0  = IR6 IR1IR0  :  AND; 
2. Y1  = IR6IR1IR0  :  ADD;
3. Y2  = IR6IR1IR0  :  SUB;
4. Y3  = IR6IR2  :  LDA;
5. Y4  = IR6IR3  :  STA;
6. Y5  = IR6IR4  :  BUN; and
7. Y6  = IR6IR5  :  ISZ.
These “designations” for Xi and Yj will be used in the following sections.
The following three tables detail the instruction cycles; you have to read and analyse these tables attentively and make sure that you understand each step. These tables represent the specifications for the design of the CPU Control Unit. The ALU functions are described in TABLE 5. Please note that  register-reference instructions require only one memory READ cycle (to get the opcode in T3),
memory-reference instructions in direct addressing mode need three memory READ cycles:
o 2 READ cycles to fetch the instruction (one for the opcode in T3  and another one for the operand address in T6), and
o a third READ cycle to get the operand in T8  (if needed) to execute the instruction,
memory-reference instructions in indirect addressing mode need four memory READ cycles (3 READ cycles to fetch the instruction – the 1st  READ cycle to read the opcode in T3, the 2nd  READ cycle to read the address of the operand address in T6, the 3rd  READ cycle to get the operand address in T7, and the 4th READ cycle to get the operand in T8 - if needed, to execute the instruction.
Table 2: Instruction Fetch Cycle (Initialisation) - common to all types of instruction 
Table 3: Instruction Execution Cycle - Control of the register - reference instructions 
Table 4: Instruction Execution Cycle - Control of the memory - reference instructions 
Table 5: ALU operations table 
To illustrate the computer’s operation, let’s track the registers contents as the following memory – reference instruction is run:
00:       ADD 80H
02:       …
This translates into the machine code stored in the computer’s memory as follows
Addr  Content 
00:       02
01:       80
02:       …
5. Prelab - Hardware 
5.1 Files Analysis You will start up by analyzing the files .bdf which you are provided with. You can do it either by using Quartus II, or by “deciphering” the diagrams at the end of this document (Fig. 3 - 11). You don’t have to understand in detail the RAM operation (ram256x8), nor the controller of the 7-segment display. The diagram of the 4 bit SC counter is not included in the figures below, because the counter has the same architecture like the 8 bit counter, but truncated to 4 bits. Finally, the VHDL code of the bus multiplexer is presented in Table 7. Although you did not learn VHDL yet, you will see that the code is easy to understand, and much simpler to implement than would be a .bdf.
Examining the logic diagrams, answer the following questions and write your answers in your report:
1.   Draw a diagram which shows the hierarchy of the files, with lab3top at the top. For the files lab3controller, ram256x8, and sevensegcontroller, you do not have to identify the subfiles.
2.   How can you check by analysing these files that only one register will place its output on the data bus at a time?
3.   Are the register reset (clear) signals synchronous or asynchronous? Explain your answer. Note that all the command signals are active at high (i.e. a “1” will reset a register to 0).
4.   What happens if a load and a reset are simultaneously sent to a register? Why?
5.   Why the address register is connected directly to the memory?
6.   Why  the  Program  Counter,  the  Data  Register,  and  the  Accumulator  are  implemented  as counters?
7.   Of all the three commands of the counters  (reset, increment, and load), which one has the highest priority? Which one has the lowest priority? Explain your answer.
8.   Is it possible to read a value from memory directly to the accumulator? Explain your answer.
9.   Analyze the ALU and determine a truth table which describes the 8 operations which can be selected by the three control lines. Are the shift operations logical or arithmetic?
5.2 Design of the Control Unit Your main objective is to derive the equations of all the control signals which have to be generated by the Control Unit in order to control the CPU datapath (registers and ALU), the bus and the memory. To this effect, analyze the RTL expressions of Table 2, Table 3, Table 4, and write the logic expression for each of the following control signal (λ and δ functions of the Control Unit):
Memory (λM(In, T)) 
1.         memwrite CPU registers (λR(In, T)) 
2.          AR_Load
3.          PC_Load
4.          PC_Inc
5.          DR_Load
6.          DR_Inc
7.          IR_Load
8.          AC_Clear
9.          AC_Load
10.        AC_Inc
11.        OUTD_Load
CPU ALU (λALU(In, T)) 
12. ALU_Sel2
13. ALU_Sel1
14. ALU_Sel0
Bus (data mux (λBus(In, T)) 
15. BusSel2
16. BusSel1
17. BusSel0
Control Unit (δ(In, T)) 
18. SC_Clear
19. HaltThe inputs (In) of the Control Unit are: the Instruction Register IR [7..0], the Data Register DR [7..0], the State Register (SC) T[12..0], and the stop command (Stop) of the Stop register. The Xi and Yj functions  (as  described  in  section  4.3)  are  the  core  of the Instruction  Decoder and  have  to  be implemented first, to allow for deriving all the control signal (CU’s λ and δ functions) from them.To this effect, examine the tables and determine which signals must be activated to execute each RTL line. For each control signal, derive a list of the conditions under which that signal is activated. After making up the list for a particular signal, you can simply do an OR of each condition/term to obtain the final expression of that control signal. For example, let consider the bus (multiplexer) for which three select lines (BusSel [2..0]) have to be derived (λBus(In, T)). Let synthesize in a table all the conditions under which each register places its output onto the bus:From this table, one can see that BusSel2 = T0  + T9Y4  . Actually you have to design an encoder that generates BusSel [2..0] in terms of the Control Conditions. Similar Boolean expressions have to be derived for all the other control signals. To eliminate the dependence of the duration of the output functions λ(In, T) and transition functions δ(In, T) to the input signals, every function is sampled and stored in a buffer synchronously with the system clock.
It is worth to pay great attention when you derive your lists!
6. Procedure - Hardware 
6.1 Build and test the Control Unit 
6.1.1 Automatic run 
1. Create a new Quartus II Project and name it appropriately with File  New Project Wizard or File  New  New Quartus II Project 
Add support files (both .bdf and .vhd) to project: ProjectAdd/Remove Files from Project Set lab3top.bdf as the top-level entity.
2.   Open the file lab3controller.bdf (which gives the list of the pins of the inputs and outputs in the order required for generating by default the same symbol as shown in the file lab3top.bdf). Use AND, OR and NOT gates to implement the Boolean expressions that you derived in the prelab for the control signals (section 5.3). It is a good idea to make virtual connections by giving names to wires (simply click on a wire and enter the name; the wires which have the same names are automatically connected by the compiler). If you do not use virtual connections, your file will quickly become an incomprehensible set of spaghetti. Try to reduce the number of logic gates that a signal must go through. The clock period of the DE2-115 board is only 20 ns, and errors can occur if signals are delayed over this period. 
3.   Create  your  Memory  Initialization  File  (memorycontents8.mif): File  New  Memory Initialization File; Select your radix etc... Hexadecimal. You can either put your test program into the *.mif (like the one in Fig. 2) now or later. Save the file.
4.   Set lab3controller.bdf as Top-Level Entity and make sure that it compiles without errors.
5.   Assign lab3top.bdf to  the  project  (set  as Top-Level Entity),  and  choose  the  device EP4CE115F29C7. Assign the pins as shown in Table 6. (right-click on pin Locate  Locate in Assignment Editor and then switch in the Category panel from All to Locations-Pins to select the pin in the Edit panel, in the Location tab, etc …
Table 6: Pins Assignment 
Compile your project.
6.   To test and visualise the simulation of your project, create a new .vwf file called lab3top.vwf. Choose a grid size of 20 ns and an end of simulation of 5μs. Make a right click and select “Insert” then “Insert Node or Bus …” and then click on “node finder” and on “List” selecting Pins: all for Filter, and Named “*” . In the panel Nodes Found select clk, DIP [7..0], etc.
7.   Set the DIP switches to point to the A0 address. Also make sure the Auto signal is set to 1. Start simulation. If your Control Unit functions correctly, the register OUTD would have at the end the value 5F, and the Stop bit should be activated after approximately 2.7 μs. If you start again your simulation with DIP [7..0] set to A1, the register OUTD should finally contain FA. Show this simulation to your TA. 
6.1.2 Manual run 
8.   If your simulation does not function, you have to find the source of the problem. Run short test programs (a couple of instructions) to verify the correct generation of the control signals. To help debug the issue, set the Auto signal to 0. Setting the Auto signal to 0 enables you to step- through the instructions (a push-button press 1_instruction, permits the user to execute the next instruction) and see where the issue is. In addition, the outputs to the following registers are displayed as well: AR, DR and the Accumulator.Check the sequence of the control signals to see whether they correspond to the order described in tables 2 - 4. Keep in mind that the signals arrive one clock cycle after the sequence counter, as they are stored first in the control registers. Another good technique of checking is to observe what is stored in the memory. Examine the signals on the data and address buses each time the signal memwrite is requested; this should help you to find out where your program causes an error.
9.   Program the DE2-115 board by opening the programmer and choose “Program” . Use the DIP switches to choose the addresses for the data.
10. Enter the program of Section 4.3 in memorycontents8.mif. Program the device and use the DIP switches to read the memory content. Was your analysis of the program correct? Demonstrate to your TA. 


         
加QQ：99515681  WX：codinghelp
